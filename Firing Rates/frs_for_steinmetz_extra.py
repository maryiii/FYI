# -*- coding: utf-8 -*-
"""FRs for steinmetz_extra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xhIpD_xv80lImLZzCA1Bw7Xoq_3Dzl4M

## Loading of Steinmetz data

includes some visualizations
"""

#@title Data retrieval
import os, requests

fname = ['steinmetz_st.npz']
fname.append('steinmetz_wav.npz')
fname.append('steinmetz_lfp.npz')

url = ["https://osf.io/4bjns/download"]
url.append("https://osf.io/ugm9v/download")
url.append("https://osf.io/kx3v9/download")

for j in range(len(url)):
  if not os.path.isfile(fname[j]):
    try:
      r = requests.get(url[j])
    except requests.ConnectionError:
      print("!!! Failed to download data !!!")
    else:
      if r.status_code != requests.codes.ok:
        print("!!! Failed to download data !!!")
      else:
        with open(fname[j], "wb") as fid:
          fid.write(r.content)

#@title Import matplotlib and set defaults
from matplotlib import rcParams 
from matplotlib import pyplot as plt
rcParams['figure.figsize'] = [20, 4]
rcParams['font.size'] =15
rcParams['axes.spines.top'] = False
rcParams['axes.spines.right'] = False
rcParams['figure.autolayout'] = True

#@title Data loading
import numpy as np

dat_LFP = np.load('steinmetz_lfp.npz', allow_pickle=True)['dat']
dat_WAV = np.load('steinmetz_wav.npz', allow_pickle=True)['dat']
dat_ST = np.load('steinmetz_st.npz', allow_pickle=True)['dat']


# select just one of the recordings here. 11 is nice because it has some neurons in vis ctx. 
dat = dat_LFP[11]
print(dat.keys())
dat = dat_WAV[11]
print(dat.keys())
dat = dat_ST[0]
print(dat.keys())

dat_ss = dat['ss']
np.savez('dat_ss',dat_ss=dat_ss)

print(np.shape(dat_ST[11]['ss']))

"""`dat_LFP`, `dat_WAV`, `dat_ST` contain 39 sessions from 10 mice, data from Steinmetz et al, 2019, supplemental to the main data provided for NMA. Time bins for all measurements are 10ms, starting 500ms before stimulus onset (same as the main data). The followin fields are available across the three supplemental files. 

* `dat['lfp']`: recording of the local field potential in each brain area from this experiment, binned at `10ms`.
* `dat['brain_area_lfp']`: brain area names for the LFP channels. 
* `dat['trough_to_peak']`: measures the width of the action potential waveform for each neuron. Widths `<=10` samples are "putative fast spiking neurons". 
* `dat['waveform_w']`: temporal components of spike waveforms. `w@u` reconstructs the time by channels action potential shape. 
* `dat['waveform_u]`: spatial components of spike waveforms.
* `dat['ss']`: neurons by trials. Exact spikes times for each neuron and each trial, reference to the stimulus onset. A (neuron,trial) entry can be an empty list if that neuron did not fire at all on that trial. 
* `dat['%X%_passive']`: same as above for `X` = {`lfp`, `ss`} but for  passive trials at the end of the recording when the mouse was no longer engaged and stopped making responses.
"""

dat_passive = dat_ST[1]['ss_passive']

def firing_rates_passive (session):

  dat_passive = dat_ST[session]['ss_passive']
  FR_passive = []


  for i in range(np.shape(dat_passive)[0]):
    neur_passive = []
    for j in range(np.shape(dat_passive)[1]):
      spike_times_passive = dat_passive[i,j]
      ipi_passive = np.diff(spike_times_passive)
      neur_passive.append(1/np.mean(ipi_passive))
    FR_passive.append(neur_passive)   

  FR_passive = np.nanmean(FR_passive,axis = 1)  
  FR_passive = np.nan_to_num(FR_passive)
  return FR_passive

FR_passive_0 = firing_rates_passive(0)   #change x 2
np.savez("FR_passive_0.npz", FR_passive_0 = FR_passive_0 )    #change x 3

import pickle


with open('output_passive_0', 'rb') as handle:
    b = pickle.load(handle)
print(b)

# groupings of brain regions
regions = ["vis ctx", "thal", "hipp", "other ctx", "midbrain", "basal ganglia", "cortical subplate", "other"]
brain_groups = [["VISa", "VISam", "VISl", "VISp", "VISpm", "VISrl"], # visual cortex
                ["CL", "LD", "LGd", "LH", "LP", "MD", "MG", "PO", "POL", "PT", "RT", "SPF", "TH", "VAL", "VPL", "VPM"], # thalamus
                ["CA", "CA1", "CA2", "CA3", "DG", "SUB", "POST"], # hippocampal
                ["ACA", "AUD", "COA", "DP", "ILA", "MOp", "MOs", "OLF", "ORB", "ORBm", "PIR", "PL", "SSp", "SSs", "RSP"," TT"], # non-visual cortex
                ["APN", "IC", "MB", "MRN", "NB", "PAG", "RN", "SCs", "SCm", "SCig", "SCsg", "ZI"], # midbrain
                ["ACB", "CP", "GPe", "LS", "LSc", "LSr", "MS", "OT", "SNr", "SI"], # basal ganglia 
                ["BLA", "BMA", "EP", "EPd", "MEA"] # cortical subplate
                ]

"""Firing Rates"""

def firing_rates (session):

  dat = dat_ST[session]['ss']
  FR = []


  for i in range(np.shape(dat)[0]):
    neur = []
    for j in range(np.shape(dat)[1]):
      spike_times = dat[i,j]
      ipi = np.diff(spike_times)
      neur.append(1/np.mean(ipi))
    FR.append(neur)   

  FR = np.nanmean(FR,axis = 1)  
  FR = np.nan_to_num(FR)
  return FR

FR_0 = firing_rates(0)   #change x 2
np.savez("FR_0.npz", FR_0 = FR_0 )    #change x 3 
# FR_1 = firing_rates(1).tolist()
# for _ in range(len(FR_1)):

# from google.colab import files
# files.download("FR_1.npz")
# numpy.savez_compressed("FR_1",)
# print(FR_1[:10])

"""# New Section

session
"""

#@title Data loading
import pickle
import numpy as np

number = 38 #change NO
dat_ST = np.load('steinmetz_st.npz', allow_pickle=True)['dat']
dat = dat_ST[number] #change NO
print(dat.keys())

beh_data = np.load('alldat_beh.npy',allow_pickle=True)
beh_data = beh_data[number] #change NO
spks = dat['ss']

dat_br = np.load('brain_areas.npz',allow_pickle=True)['br'][number]  #change NO

"""passive FRs & mixed results"""

def firing_rates_passive (session):

  dat_passive = dat_ST[session]['ss_passive']
  FR_passive = []


  for i in range(np.shape(dat_passive)[0]):
    neur_passive = []
    for j in range(np.shape(dat_passive)[1]):
      spike_times_passive = dat_passive[i,j]
      ipi_passive = np.diff(spike_times_passive)
      neur_passive.append(1/np.mean(ipi_passive))
    FR_passive.append(neur_passive)   

  FR_passive = np.nanmean(FR_passive,axis = 1)  
  FR_passive = np.nan_to_num(FR_passive)
  return FR_passive

FR_passive = firing_rates_passive(number)   


FR_passive_n=[]
for jj in range(len(dat_br)):
    FR_passive_n.append(FR_passive[jj])

output_pass = list(zip(dat_br,FR_passive_n))

def Convert(tup,di):
    for a,b in tup:
        di.setdefault(a,[]).append(b)
    return di

output_passive = {}  
Convert(output_pass,output_passive)  

for key in output_passive:
    output_passive[key] = np.mean(output_passive[key])


with open('output_passive_mixed_38', 'wb') as handle: #change NO
   pickle.dump(output_passive , handle, protocol=pickle.HIGHEST_PROTOCOL)

"""separation"""

feedback =  beh_data['feedback_type']
c_right = beh_data['contrast_right']
c_left = beh_data['contrast_left']
pos_trials = np.logical_and(feedback==1,c_right!=c_left)
neg_trials = np.logical_and(feedback==-1,c_right!=c_left)
unc_trials = c_right==c_left

pos_spks = spks[:,pos_trials]
neg_spks = spks[:,neg_trials]
unc_spks = spks[:,unc_trials]

"""neg FRs & mixed results"""

print(np.shape(unc_spks))
print(np.shape(FR_unc))

FR_neg=[]
an,bn = np.shape(neg_spks)

for i_n in range(an):
  neur_n = []
  for j_n in range(bn):
    spike_times_n = neg_spks[i_n,j_n]
    ipi_n = np.diff(spike_times_n)
    neur_n.append(1/np.mean(ipi_n))
  FR_neg.append(neur_n)   

FR_neg = np.nanmean(FR_neg,axis = 1)  
FR_neg = np.nan_to_num(FR_neg)


FR_neg_n=[]
for kk in range(len(dat_br)):
    FR_neg_n.append(FR_neg[kk])

output_n = list(zip(dat_br,FR_neg_n))

def Convert(tup,di):
    for a,b in tup:
        di.setdefault(a,[]).append(b)
    return di

output_neg = {}  
Convert(output_n,output_neg)  

for key in output_neg:
    output_neg[key] = np.mean(output_neg[key])


with open('output_neg_mixed_38', 'wb') as handle: #change NO
   pickle.dump(output_neg , handle, protocol=pickle.HIGHEST_PROTOCOL)  



# output_neg = {'brain_areas': dat_br, 'FR_neg': FR_neg}


# np.savez("FR_neg_38.npz", FR_neg = FR_neg) #change NO

"""pos FRs & mixed results"""

FR_pos=[]
ap,bp = np.shape(pos_spks)

for i_p in range(ap):
  neur_p = []
  for j_p in range(bp):
    spike_times_p = pos_spks[i_p,j_p]
    ipi_p = np.diff(spike_times_p)
    neur_p.append(1/np.mean(ipi_p))
  FR_pos.append(neur_p)   

FR_pos = np.nanmean(FR_pos,axis = 1)  
FR_pos = np.nan_to_num(FR_pos)

FR_pos_n=[]
for ll in range(len(dat_br)):
    FR_pos_n.append(FR_pos[ll])

output_p = list(zip(dat_br,FR_pos_n))

def Convert(tup,di):
    for a,b in tup:
        di.setdefault(a,[]).append(b)
    return di

output_pos = {}  
Convert(output_p,output_pos)  

for key in output_pos:
    output_pos[key] = np.mean(output_pos[key])


with open('output_pos_mixed_38', 'wb') as handle: #change NO
   pickle.dump(output_pos , handle, protocol=pickle.HIGHEST_PROTOCOL)  

# output_pos = {'brain_areas': dat_br, 'FR_pos': FR_pos}

# np.savez("FR_pos_38.npz", FR_pos = FR_pos) #change NO

"""unc FRs & mixed results"""

FR_unc=[]
au,bu = np.shape(unc_spks)

for i_u in range(au):
  neur_u = []
  for j_u in range(bu):
    spike_times_u = unc_spks[i_u,j_u]
    ipi_u = np.diff(spike_times_u)
    neur_u.append(1/np.mean(ipi_u))
  FR_unc.append(neur_u)   

FR_unc = np.nanmean(FR_unc,axis = 1)  
FR_unc = np.nan_to_num(FR_unc)

FR_unc_n=[]
for mm in range(len(dat_br)):
    FR_unc_n.append(FR_unc[mm])

output_u = list(zip(dat_br,FR_unc_n))

def Convert(tup,di):
    for a,b in tup:
        di.setdefault(a,[]).append(b)
    return di

output_unc = {}  
Convert(output_u,output_unc)  

for key in output_unc:
    output_unc[key] = np.mean(output_unc[key])


with open('output_unc_mixed_38', 'wb') as handle: #change NO
   pickle.dump(output_unc , handle, protocol=pickle.HIGHEST_PROTOCOL)  

# output_unc = {'brain_areas': dat_br, 'FR_unc': FR_unc} 

# np.savez("FR_unc_38.npz", FR_unc = FR_unc) #change NO

"""mixing outpus"""

#loading

with open('output_final_passive_37', 'rb') as handle: #change no-1
    pas = pickle.load(handle)

with open('output_final_negative_37', 'rb') as handle:  #change no-1
    nega = pickle.load(handle)

with open('output_final_positive_37', 'rb') as handle: #change no-1
    posi = pickle.load(handle)

with open('output_final_uncertain_37', 'rb') as handle:  #change no-1
    unce = pickle.load(handle)

print(len(output_final_uncertain.keys()))

#mixing and adding brain areas and mean FRs to previous values

list_newpa = [(kpa, vpa) for kpa, vpa in output_passive.items()] 
list_newn = [(kn, vn) for kn, vn in output_neg.items()] 
list_newp = [(kp, vp) for kp, vp in output_pos.items()] 
list_newu = [(ku, vu) for ku, vu in output_unc.items()] 


def Convert(tup,di):
    for w,y in tup:
        di.setdefault(w,[]).append(y)
    return di

output_final_passive = {} 
output_final_negative = {} 
output_final_positive = {} 
output_final_uncertain = {} 

output_final_passive = pas 
output_final_negative = nega 
output_final_positive = posi 
output_final_uncertain = unce

Convert(list_newpa,output_final_passive) 
Convert(list_newn,output_final_negative)
Convert(list_newp,output_final_positive)
Convert(list_newu,output_final_uncertain)



with open('output_final_passive_38', 'wb') as handle: #change NO
   pickle.dump(output_final_passive , handle, protocol=pickle.HIGHEST_PROTOCOL) 

with open('output_final_negative_38', 'wb') as handle: #change NO
   pickle.dump(output_final_negative , handle, protocol=pickle.HIGHEST_PROTOCOL) 

with open('output_final_positive_38', 'wb') as handle: #change NO
   pickle.dump(output_final_positive , handle, protocol=pickle.HIGHEST_PROTOCOL) 

with open('output_final_uncertain_38', 'wb') as handle: #change NO
   pickle.dump(output_final_uncertain , handle, protocol=pickle.HIGHEST_PROTOCOL) 



# # def update_dic(dict, key): 
      
# #     if key in dict: 
# #         dict.setdefault(key, [])
# #         dict[key].append() 
# #     else: 
# #         dict.update(key)

# gggg=output_pos
# for key in gggg:
#   if key in gggg: 
#         gggg.setdefault(key, [])
#         gggg[key].append() 
#   else: 
#         gggg.update(key)
# # gggg = update_dic(output_neg,'VISP')

print(output_final.keys())
print(b.keys())

"""Saving"""

import pickle

# output_neg = {'brain_areas': dat_br, 'FR_neg': FR_neg}
# output_pos = {'brain_areas': dat_br, 'FR_pos': FR_pos}
# output_unc = {'brain_areas': dat_br, 'FR_unc': FR_unc} 

with open('output_FRneg_38', 'wb') as handle: #change number
   pickle.dump(output_neg, handle, protocol=pickle.HIGHEST_PROTOCOL)  

with open('output_FRpos_38', 'wb') as handle: #change number
   pickle.dump(output_pos, handle, protocol=pickle.HIGHEST_PROTOCOL)  

with open('output_FRunc_38', 'wb') as handle: #change number
   pickle.dump(output_unc, handle, protocol=pickle.HIGHEST_PROTOCOL)

